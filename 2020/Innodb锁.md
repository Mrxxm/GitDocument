## Innodb锁

#### 1.Laravel文档中的悲观锁

* `sharedLock`

```
DB::table('users')->where('id', '=',2)->sharedLock()->get();
```

* `lockForUpdate`

```
DB::table('users')->where('votes', '>', 100)->sharedLock()->get();
```

* 调试(`dd()`、`dump()`都可输出`sql`语句)

```
DB::table('users')->where('id', '=',2)->sharedLock()->dd();

DB::table('users')->where('votes', '>', 100)->sharedLock()->dump();
```

* 输出

```
select * from `user` where `id` = 2 lock in share mode;
select * from `user` where `id` = 2 for update;
```

#### 2.乐观锁和悲观锁

锁的种类一般分为**乐观锁**和**悲观锁**两种，`InnoDB`存储引擎中使用的就是**悲观锁**，而按照锁的**粒度**划分，也可以分成行锁和表锁:

  * **悲观锁**就是一种真正的锁了，它会在获取资源前对资源进行加锁，确保同一时刻只有有限的线程能够访问该资源，其他想要尝试获取资源的操作都会进入等待状态，直到该线程完成了对资源的操作并且释放了锁后，其他线程才能重新操作资源；
  * **乐观锁**是一种思想，它其实并不是一种真正的『锁』，它会先尝试对资源进行修改，在写回时判断资源是否进行了改变，如果没有发生改变就会写回，否则就会进行重试，在整个的执行过程中其实都没有对数据库进行加锁；

#### 3.Innodb存储引擎特性之一

* 事务

```
1.什么是事务

  * 事务是数据库系统区别于其他一切文件系统的重要特性之一
  * 事务是一组具有原子性(要么全部完成，要么全部失败)的SQL语句，或是一个独立的工作单元
  * 原子性、一致性、隔离性、持久性
```

* 事务的`ACID`特性

```
原子性
  * 一个事务必须被视为一个不可分割的最小工作单元，对于一个事务来说，不可能只执行其中的一部分操作

一致性
  * 一致性是指事务将数据库从一种一致性状态到另一种一致性状态，在事务开始之前和事务结束后数据库中数据的完整性没有被破坏

持久性
  * 一旦事务被提交，则其所做的修改就会永久保存到数据库中。即使，此时系统崩溃，已经提交的修改数据也不会丢失  

隔离性 
  * 隔离性要求一个事务对数据库中数据的修改，在未提交完成前对于其他事务是不可见的 
```

* `SQL`标准中定义的四种隔离级别

```
  * 未提交读 [READ UNCOMMITED] (对数据进行修改，事务还没有被提交，对其他事务都是可见的，事务可以读取未提交的数据-脏读)
  * 已提交读 [READ COMMITED] (大多数据库中的默认级别，满足事务的隔离性的定义)
  * 可重复读 [REPEATABLE READ] (InnoDB中的默认级别，在同一个事务中，多次读取同样的记录的结果是一致的)
  * 可串行化 [SERIALIZABLE] (最高隔离级别，在读取的每行数据上都加锁，可能导致大量的锁超时锁征用问题，实际中很少使用)
```

#### 4.事务的隔离性-已提交读-可重复读区别

* 总结：

```
  * 已提交读：当前事务中会读到另一个事务插入的数据(已提交读)
  * 可重复读：当前事务中不会读到另一个事务中插入的数据(幻读)
```

* 实验(可重复读)：

![](https://img3.doubanio.com/view/photo/l/public/p2627991311.jpg)

* 实验(已提交读):

![](https://img3.doubanio.com/view/photo/l/public/p2627991401.jpg)

#### 5.事务的并发问题

```
1、脏读：事务 A 读取了事务 B 更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
2、已提交读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。
3、幻读：事务 A 将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是事务B就在这个时候插入了一条具体分数的记录，事务A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。
小结：已提交读的和幻读很容易混淆，脏读、已提交读侧重于修改，幻读侧重于新增或删除。
     解决已提交读的问题只需锁住满足条件的行，解决幻读需要锁表。
```

#### 6.Innodb中的锁

* 什么是锁 (锁是数据库系统区别于文件系统的重要特性)

```
1.锁的主要作用是管理共享资源的并发访问 (同一个邮箱同时写入两封邮件的例子：在一封邮件写入时，会阻塞另一封邮件的写入)
2.锁用于实现事务的隔离性 
```

* 锁的类型

```
1.共享锁 (读锁)(S)
2.独占锁 (写锁)(X)
```


|  | 写锁 | 读锁 |
| --- | --- | --- |
| 写锁 | 不兼容 | 不兼容 |
| 读锁 | 不兼容 | 兼容  |

**对同一资源读写请求应该是互斥的，实际体验并不和以上的情况相同。**

* 实验

  `window2`的`step3`查询并没有被连接一的写锁所阻塞，这和上面介绍的兼容性不符。这里`Innodb`利用未介绍的**`Undo Log`**中的记录，我们这里连接查看的数据时存储在`Undo Log`中的版本，其实`Innodb`中还存在**意向共享锁**、**意向独占锁**，这是为了支持在不同粒度上加锁而设计的

![](https://img9.doubanio.com/view/photo/l/public/p2627991444.jpg)


* 锁的粒度 
  
  被加锁的最小单位 例：在行上加锁，则锁的粒度就是行 [对需要修改的内容，锁的粒度越小，则系统并发性越高，只要相互之间不产生阻塞就好]

```
  * 表级锁 (通常在Mysql数据服务层面所实现的) [虽然Innodb实现行级锁，但在有些情况下mysql数据服务层还是会对Innodb表加上表级锁]
  * 行级锁 (最大程度支持并发处理，锁的开销比表级锁要大)
```

* 实验(表锁)

  `step2`中查询被阻塞，直到`unlock tables`才查询到结果。

![](https://img2.doubanio.com/view/photo/l/public/p2627991492.jpg)

#### 7.阻塞和死锁

* 什么是阻塞 

  阻塞是因为不同锁之间兼容性的关系，在有些时刻，一个事务中的锁要等到另一个事务中的锁的释放，它所占用的资源，这就形成了阻塞
  
  阻塞是为了确保事务的可以并发且正常的运行 (当系统中存在大量的阻塞，则表明存在大量的问题) [大量阻塞：在一个频繁更新的表上出现慢查询，还有可能出现在表备份时，对一个频繁访问的资源加上了排它锁]

* 什么是死锁(`deadlock`) 

  是指两个或两个以上的事务在执行过程中相互占用了对方等待的资源，而产生一种异常
  
  阻塞只是占用了被阻塞事务的资源，而死锁是产生事务的多个事务之间相互占有对方等待的资源 (死锁可由系统自动处理)
  
#### 8.`for update` 与 `lock in share mode`的区别

回到开头文档中提及的语句。

```
* lock in share mode 意向共享锁(IS)
* for update         意向排他锁(IX)
```

* `for update`与`lock in share mode`是应用于并发情况下对数据进行加锁操作，分别用数据 事务A（先）和 事务B（后）来描述并发操作。

```
相同点：
  1.两者都会对并发的操作造成阻塞，等待A操作完成；
  2.B查询操作不会造成阻塞(不带for update)
  3.B查询操作阻塞(带for update)
  
不同点：
  1.并发时for update会使B一直阻塞，等待A操作完成后执行B操作
  2.而在使用lock in share mode下当B阻塞时，如果A继续有修改数据，那么此时B会终止失败  
```

* 实验(`for update`)

![](https://img3.doubanio.com/view/photo/l/public/p2627991550.jpg)

* 实验(`lock in share mode`)

![](https://img3.doubanio.com/view/photo/l/public/p2627991580.jpg)



 